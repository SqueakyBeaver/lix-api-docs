<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nix: nix::Store Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nix
   &#160;<span id="projectnumber">2.93.0-dev</span>
   </div>
   <div id="projectbrief">Lix: A modern, delicious implementation of the Nix package manager; unstable internal interfaces</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classnix_1_1Store.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classnix_1_1Store-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">nix::Store Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for nix::Store:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classnix_1_1Store__inherit__graph.svg" width="1171" height="450"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for nix::Store:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classnix_1_1Store__coll__graph.svg" width="346" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnix_1_1Store_1_1PathInfoCacheValue.html">PathInfoCacheValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnix_1_1Store_1_1State.html">State</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnix_1_1Store_1_1Stats.html">Stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed97c14118868d419851977844ed4f96" id="r_aed97c14118868d419851977844ed4f96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed97c14118868d419851977844ed4f96">PathsSource</a></td></tr>
<tr class="separator:aed97c14118868d419851977844ed4f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5af7b0c2fd14332d3ce5db0c6761f0f" id="r_ae5af7b0c2fd14332d3ce5db0c6761f0f"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5af7b0c2fd14332d3ce5db0c6761f0f">init</a> ()</td></tr>
<tr class="separator:ae5af7b0c2fd14332d3ce5db0c6761f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054217aebbe9d23549700eb8aa43a91c" id="r_a054217aebbe9d23549700eb8aa43a91c"><td class="memItemLeft" align="right" valign="top"><a id="a054217aebbe9d23549700eb8aa43a91c" name="a054217aebbe9d23549700eb8aa43a91c"></a>
virtual <a class="el" href="structnix_1_1StoreConfig.html">StoreConfig</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>config</b> ()=0</td></tr>
<tr class="separator:a054217aebbe9d23549700eb8aa43a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080e2230e7c4f22f041478776182e0f2" id="r_a080e2230e7c4f22f041478776182e0f2"><td class="memItemLeft" align="right" valign="top"><a id="a080e2230e7c4f22f041478776182e0f2" name="a080e2230e7c4f22f041478776182e0f2"></a>
virtual const <a class="el" href="structnix_1_1StoreConfig.html">StoreConfig</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>config</b> () const =0</td></tr>
<tr class="separator:a080e2230e7c4f22f041478776182e0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cff065f2af74517c34321a4373f649" id="r_a08cff065f2af74517c34321a4373f649"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08cff065f2af74517c34321a4373f649">getUri</a> ()=0</td></tr>
<tr class="separator:a08cff065f2af74517c34321a4373f649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cfe25e56b62732a94f291c48f8af02" id="r_a22cfe25e56b62732a94f291c48f8af02"><td class="memItemLeft" align="right" valign="top"><a id="a22cfe25e56b62732a94f291c48f8af02" name="a22cfe25e56b62732a94f291c48f8af02"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseStorePath</b> (std::string_view path) const</td></tr>
<tr class="separator:a22cfe25e56b62732a94f291c48f8af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8419332f814f52ddbdd453e76817227b" id="r_a8419332f814f52ddbdd453e76817227b"><td class="memItemLeft" align="right" valign="top"><a id="a8419332f814f52ddbdd453e76817227b" name="a8419332f814f52ddbdd453e76817227b"></a>
std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>maybeParseStorePath</b> (std::string_view path) const</td></tr>
<tr class="separator:a8419332f814f52ddbdd453e76817227b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d855740705cf9043cdc9b80ec3973a" id="r_a37d855740705cf9043cdc9b80ec3973a"><td class="memItemLeft" align="right" valign="top"><a id="a37d855740705cf9043cdc9b80ec3973a" name="a37d855740705cf9043cdc9b80ec3973a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>printStorePath</b> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path) const</td></tr>
<tr class="separator:a37d855740705cf9043cdc9b80ec3973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d5a6d2d5e933c5a0aa2f4b3a0939e3" id="r_a57d5a6d2d5e933c5a0aa2f4b3a0939e3"><td class="memItemLeft" align="right" valign="top">StorePathSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d5a6d2d5e933c5a0aa2f4b3a0939e3">parseStorePathSet</a> (const PathSet &amp;paths) const</td></tr>
<tr class="separator:a57d5a6d2d5e933c5a0aa2f4b3a0939e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fe3a4e731d5f3b486d95933b0687f8" id="r_ad5fe3a4e731d5f3b486d95933b0687f8"><td class="memItemLeft" align="right" valign="top"><a id="ad5fe3a4e731d5f3b486d95933b0687f8" name="ad5fe3a4e731d5f3b486d95933b0687f8"></a>
PathSet&#160;</td><td class="memItemRight" valign="bottom"><b>printStorePathSet</b> (const StorePathSet &amp;path) const</td></tr>
<tr class="separator:ad5fe3a4e731d5f3b486d95933b0687f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8542ed8b485ab578c7235bc93a4920d" id="r_ac8542ed8b485ab578c7235bc93a4920d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8542ed8b485ab578c7235bc93a4920d">showPaths</a> (const StorePathSet &amp;paths)</td></tr>
<tr class="separator:ac8542ed8b485ab578c7235bc93a4920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76a077a45e877f1173ee4bc90f2e775" id="r_ab76a077a45e877f1173ee4bc90f2e775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab76a077a45e877f1173ee4bc90f2e775">isInStore</a> (PathView path) const</td></tr>
<tr class="separator:ab76a077a45e877f1173ee4bc90f2e775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7f8f6338f1b97e1ff5e6f2511d181e" id="r_aea7f8f6338f1b97e1ff5e6f2511d181e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea7f8f6338f1b97e1ff5e6f2511d181e">isStorePath</a> (std::string_view path) const</td></tr>
<tr class="separator:aea7f8f6338f1b97e1ff5e6f2511d181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af964f508806321bde6423c52a2634671" id="r_af964f508806321bde6423c52a2634671"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a>, <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af964f508806321bde6423c52a2634671">toStorePath</a> (PathView path) const</td></tr>
<tr class="separator:af964f508806321bde6423c52a2634671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900ae582df895315fc7001c03806e939" id="r_a900ae582df895315fc7001c03806e939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a900ae582df895315fc7001c03806e939">followLinksToStore</a> (std::string_view path) const</td></tr>
<tr class="separator:a900ae582df895315fc7001c03806e939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5320ff7f00646d88edf09443dfae2d" id="r_a5f5320ff7f00646d88edf09443dfae2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f5320ff7f00646d88edf09443dfae2d">followLinksToStorePath</a> (std::string_view path) const</td></tr>
<tr class="separator:a5f5320ff7f00646d88edf09443dfae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b14286cafeb77a9de91491523bf7584" id="r_a2b14286cafeb77a9de91491523bf7584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b14286cafeb77a9de91491523bf7584">makeStorePath</a> (std::string_view type, std::string_view hash, std::string_view name) const</td></tr>
<tr class="separator:a2b14286cafeb77a9de91491523bf7584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec64bedbae7eaa76f8a144cf283fd0a6" id="r_aec64bedbae7eaa76f8a144cf283fd0a6"><td class="memItemLeft" align="right" valign="top"><a id="aec64bedbae7eaa76f8a144cf283fd0a6" name="aec64bedbae7eaa76f8a144cf283fd0a6"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeStorePath</b> (std::string_view type, const <a class="el" href="structnix_1_1Hash.html">Hash</a> &amp;hash, std::string_view name) const</td></tr>
<tr class="separator:aec64bedbae7eaa76f8a144cf283fd0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0753505353e744182851d0b8ed44da4" id="r_ab0753505353e744182851d0b8ed44da4"><td class="memItemLeft" align="right" valign="top"><a id="ab0753505353e744182851d0b8ed44da4" name="ab0753505353e744182851d0b8ed44da4"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeOutputPath</b> (std::string_view id, const <a class="el" href="structnix_1_1Hash.html">Hash</a> &amp;hash, std::string_view name) const</td></tr>
<tr class="separator:ab0753505353e744182851d0b8ed44da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7962e0166215c0b7760c50ed73005650" id="r_a7962e0166215c0b7760c50ed73005650"><td class="memItemLeft" align="right" valign="top"><a id="a7962e0166215c0b7760c50ed73005650" name="a7962e0166215c0b7760c50ed73005650"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeFixedOutputPath</b> (std::string_view name, const <a class="el" href="structnix_1_1FixedOutputInfo.html">FixedOutputInfo</a> &amp;info) const</td></tr>
<tr class="separator:a7962e0166215c0b7760c50ed73005650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac668c8b58d2c5bcc9ff1c723fae2614a" id="r_ac668c8b58d2c5bcc9ff1c723fae2614a"><td class="memItemLeft" align="right" valign="top"><a id="ac668c8b58d2c5bcc9ff1c723fae2614a" name="ac668c8b58d2c5bcc9ff1c723fae2614a"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeTextPath</b> (std::string_view name, const <a class="el" href="structnix_1_1TextInfo.html">TextInfo</a> &amp;info) const</td></tr>
<tr class="separator:ac668c8b58d2c5bcc9ff1c723fae2614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698450109710baf1e7928c8c89b03af" id="r_ae698450109710baf1e7928c8c89b03af"><td class="memItemLeft" align="right" valign="top"><a id="ae698450109710baf1e7928c8c89b03af" name="ae698450109710baf1e7928c8c89b03af"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeFixedOutputPathFromCA</b> (std::string_view name, const <a class="el" href="structnix_1_1ContentAddressWithReferences.html">ContentAddressWithReferences</a> &amp;ca) const</td></tr>
<tr class="separator:ae698450109710baf1e7928c8c89b03af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba656626eada43819c054fe04e7036" id="r_af4ba656626eada43819c054fe04e7036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4ba656626eada43819c054fe04e7036">computeStorePathForPathRecursive</a> (std::string_view name, const <a class="el" href="structnix_1_1PreparedDump.html">PreparedDump</a> &amp;source) const</td></tr>
<tr class="separator:af4ba656626eada43819c054fe04e7036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9811dd6d2094167b221a0fb146eda3a8" id="r_a9811dd6d2094167b221a0fb146eda3a8"><td class="memItemLeft" align="right" valign="top"><a id="a9811dd6d2094167b221a0fb146eda3a8" name="a9811dd6d2094167b221a0fb146eda3a8"></a>
<a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>computeStorePathForPathFlat</b> (std::string_view name, const <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &amp;srcPath) const</td></tr>
<tr class="separator:a9811dd6d2094167b221a0fb146eda3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95a74ca6373fc7fb2b1028b70073f71" id="r_ab95a74ca6373fc7fb2b1028b70073f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnix_1_1StorePath.html">StorePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab95a74ca6373fc7fb2b1028b70073f71">computeStorePathForText</a> (std::string_view name, std::string_view s, const StorePathSet &amp;references) const</td></tr>
<tr class="separator:ab95a74ca6373fc7fb2b1028b70073f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d18dcc2bb3d5aca34f8ae5f6d70091" id="r_a74d18dcc2bb3d5aca34f8ae5f6d70091"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74d18dcc2bb3d5aca34f8ae5f6d70091">isValidPath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a74d18dcc2bb3d5aca34f8ae5f6d70091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf471f3994d70a3d176cdcef17d47cf7" id="r_aaf471f3994d70a3d176cdcef17d47cf7"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf471f3994d70a3d176cdcef17d47cf7">substitutePaths</a> (const StorePathSet &amp;paths)</td></tr>
<tr class="separator:aaf471f3994d70a3d176cdcef17d47cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800719163296e84486c5128bb1fe655d" id="r_a800719163296e84486c5128bb1fe655d"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a800719163296e84486c5128bb1fe655d">queryValidPaths</a> (const StorePathSet &amp;paths, SubstituteFlag maybeSubstitute=NoSubstitute)</td></tr>
<tr class="separator:a800719163296e84486c5128bb1fe655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af107fb3d1815c8fc3711a7b2bfda0a00" id="r_af107fb3d1815c8fc3711a7b2bfda0a00"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af107fb3d1815c8fc3711a7b2bfda0a00">queryAllValidPaths</a> ()</td></tr>
<tr class="separator:af107fb3d1815c8fc3711a7b2bfda0a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ba8ca476aa6273f160a39f3879d9c6" id="r_a23ba8ca476aa6273f160a39f3879d9c6"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1ref.html">ref</a>&lt; const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23ba8ca476aa6273f160a39f3879d9c6">queryPathInfo</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a23ba8ca476aa6273f160a39f3879d9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb914910edc81dfa19da71c3fdf9009" id="r_a4cb914910edc81dfa19da71c3fdf9009"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; std::shared_ptr&lt; const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cb914910edc81dfa19da71c3fdf9009">queryRealisation</a> (const <a class="el" href="structnix_1_1DrvOutput.html">DrvOutput</a> &amp;)</td></tr>
<tr class="separator:a4cb914910edc81dfa19da71c3fdf9009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbd0e468eeef6e7196962ed361250ed" id="r_aedbd0e468eeef6e7196962ed361250ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedbd0e468eeef6e7196962ed361250ed">pathInfoIsUntrusted</a> (const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &amp;)</td></tr>
<tr class="separator:aedbd0e468eeef6e7196962ed361250ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed25f6aa087e43b27bcab9d731ba589" id="r_a9ed25f6aa087e43b27bcab9d731ba589"><td class="memItemLeft" align="right" valign="top"><a id="a9ed25f6aa087e43b27bcab9d731ba589" name="a9ed25f6aa087e43b27bcab9d731ba589"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>realisationIsUntrusted</b> (const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &amp;)</td></tr>
<tr class="separator:a9ed25f6aa087e43b27bcab9d731ba589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedc853a718df8f6a3fbc91a686a7a52" id="r_afedc853a718df8f6a3fbc91a686a7a52"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afedc853a718df8f6a3fbc91a686a7a52">queryReferrers</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path, StorePathSet &amp;referrers)</td></tr>
<tr class="separator:afedc853a718df8f6a3fbc91a686a7a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020a11279779a0884547e42586a4f58b" id="r_a020a11279779a0884547e42586a4f58b"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a020a11279779a0884547e42586a4f58b">queryValidDerivers</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a020a11279779a0884547e42586a4f58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dea1514ac756362ef9aa4545a7d13fa" id="r_a7dea1514ac756362ef9aa4545a7d13fa"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dea1514ac756362ef9aa4545a7d13fa">queryDerivationOutputs</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a7dea1514ac756362ef9aa4545a7d13fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2234cbe43e42284e2b51eb8761675bc9" id="r_a2234cbe43e42284e2b51eb8761675bc9"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::map&lt; std::string, std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2234cbe43e42284e2b51eb8761675bc9">queryPartialDerivationOutputMap</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path, <a class="el" href="classnix_1_1Store.html">Store</a> *evalStore=nullptr)</td></tr>
<tr class="separator:a2234cbe43e42284e2b51eb8761675bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59bbf6ee8b8d6dc4dd4dfe5f8afe454" id="r_ae59bbf6ee8b8d6dc4dd4dfe5f8afe454"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::map&lt; std::string, std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae59bbf6ee8b8d6dc4dd4dfe5f8afe454">queryStaticPartialDerivationOutputMap</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:ae59bbf6ee8b8d6dc4dd4dfe5f8afe454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55907354ec2fb29435275ae794b147b" id="r_aa55907354ec2fb29435275ae794b147b"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; OutputPathMap &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55907354ec2fb29435275ae794b147b">queryDerivationOutputMap</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path, <a class="el" href="classnix_1_1Store.html">Store</a> *evalStore=nullptr)</td></tr>
<tr class="separator:aa55907354ec2fb29435275ae794b147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ffbf449453a90e66b49775d4f64cde" id="r_a74ffbf449453a90e66b49775d4f64cde"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ffbf449453a90e66b49775d4f64cde">queryPathFromHashPart</a> (const std::string &amp;hashPart)=0</td></tr>
<tr class="separator:a74ffbf449453a90e66b49775d4f64cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bc4ac5b3fc5287a901d7ad7b9e7c30" id="r_a14bc4ac5b3fc5287a901d7ad7b9e7c30"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bc4ac5b3fc5287a901d7ad7b9e7c30">querySubstitutablePaths</a> (const StorePathSet &amp;paths)</td></tr>
<tr class="separator:a14bc4ac5b3fc5287a901d7ad7b9e7c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d36d7aa385795d8e060c22073d929f" id="r_a60d36d7aa385795d8e060c22073d929f"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60d36d7aa385795d8e060c22073d929f">querySubstitutablePathInfos</a> (const StorePathCAMap &amp;paths, SubstitutablePathInfos &amp;infos)</td></tr>
<tr class="separator:a60d36d7aa385795d8e060c22073d929f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e3a945634557d90840c3e178bdbea" id="r_ac08e3a945634557d90840c3e178bdbea"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac08e3a945634557d90840c3e178bdbea">addToStore</a> (const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &amp;info, <a class="el" href="classnix_1_1AsyncInputStream.html">AsyncInputStream</a> &amp;narSource, RepairFlag repair=NoRepair, CheckSigsFlag checkSigs=CheckSigs)=0</td></tr>
<tr class="separator:ac08e3a945634557d90840c3e178bdbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf383c87b0ad7d323783291bd3bf5e64" id="r_acf383c87b0ad7d323783291bd3bf5e64"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf383c87b0ad7d323783291bd3bf5e64">addMultipleToStore</a> (<a class="el" href="#aed97c14118868d419851977844ed4f96">PathsSource</a> &amp;pathsToCopy, <a class="el" href="structnix_1_1Activity.html">Activity</a> &amp;act, RepairFlag repair=NoRepair, CheckSigsFlag checkSigs=CheckSigs)</td></tr>
<tr class="separator:acf383c87b0ad7d323783291bd3bf5e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305a1a0e32afb0999df11b1d0731a6fd" id="r_a305a1a0e32afb0999df11b1d0731a6fd"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a305a1a0e32afb0999df11b1d0731a6fd">addToStoreRecursive</a> (std::string_view name, const <a class="el" href="structnix_1_1PreparedDump.html">PreparedDump</a> &amp;source, HashType hashAlgo=HashType::SHA256, RepairFlag repair=NoRepair)</td></tr>
<tr class="separator:a305a1a0e32afb0999df11b1d0731a6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a012b703c4416e89bec5f05b502f6e" id="r_a63a012b703c4416e89bec5f05b502f6e"><td class="memItemLeft" align="right" valign="top"><a id="a63a012b703c4416e89bec5f05b502f6e" name="a63a012b703c4416e89bec5f05b502f6e"></a>
virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>addToStoreFlat</b> (std::string_view name, const <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &amp;srcPath, HashType hashAlgo=HashType::SHA256, RepairFlag repair=NoRepair)</td></tr>
<tr class="separator:a63a012b703c4416e89bec5f05b502f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650aeb5d0fd2b808e75d7f0da2e5d5ef" id="r_a650aeb5d0fd2b808e75d7f0da2e5d5ef"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a650aeb5d0fd2b808e75d7f0da2e5d5ef">addToStoreSlow</a> (std::string_view name, const <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &amp;srcPath, <a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cd">FileIngestionMethod</a> method=<a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cda556c3dd912453ae5cb3095cd5054e6f4">FileIngestionMethod::Recursive</a>, HashType hashAlgo=HashType::SHA256, std::optional&lt; <a class="el" href="structnix_1_1Hash.html">Hash</a> &gt; expectedCAHash={})</td></tr>
<tr class="separator:a650aeb5d0fd2b808e75d7f0da2e5d5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b847754a469ff071e3c49f611a3746" id="r_a62b847754a469ff071e3c49f611a3746"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62b847754a469ff071e3c49f611a3746">addToStoreFromDump</a> (<a class="el" href="classnix_1_1AsyncInputStream.html">AsyncInputStream</a> &amp;dump, std::string_view name, <a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cd">FileIngestionMethod</a> method=<a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cda556c3dd912453ae5cb3095cd5054e6f4">FileIngestionMethod::Recursive</a>, HashType hashAlgo=HashType::SHA256, RepairFlag repair=NoRepair, const StorePathSet &amp;references=StorePathSet())</td></tr>
<tr class="separator:a62b847754a469ff071e3c49f611a3746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a1e14d0bfac487c6886b3184009f7f" id="r_ab9a1e14d0bfac487c6886b3184009f7f"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a1e14d0bfac487c6886b3184009f7f">addTextToStore</a> (std::string_view name, std::string_view s, const StorePathSet &amp;references, RepairFlag repair=NoRepair)=0</td></tr>
<tr class="separator:ab9a1e14d0bfac487c6886b3184009f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6004e1965e5ab99e4af284c50cddd7d9" id="r_a6004e1965e5ab99e4af284c50cddd7d9"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6004e1965e5ab99e4af284c50cddd7d9">registerDrvOutput</a> (const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &amp;output)</td></tr>
<tr class="separator:a6004e1965e5ab99e4af284c50cddd7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c428a7a17e9994ddc5329fcf726819" id="r_a78c428a7a17e9994ddc5329fcf726819"><td class="memItemLeft" align="right" valign="top"><a id="a78c428a7a17e9994ddc5329fcf726819" name="a78c428a7a17e9994ddc5329fcf726819"></a>
virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>registerDrvOutput</b> (const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &amp;output, CheckSigsFlag checkSigs)</td></tr>
<tr class="separator:a78c428a7a17e9994ddc5329fcf726819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbaff078efae29478dc8e29497e9d39" id="r_afdbaff078efae29478dc8e29497e9d39"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1box__ptr.html">box_ptr</a>&lt; <a class="el" href="structnix_1_1Source.html">Source</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdbaff078efae29478dc8e29497e9d39">narFromPath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)=0</td></tr>
<tr class="separator:afdbaff078efae29478dc8e29497e9d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244cd333d19e60463349db772ba0c635" id="r_a244cd333d19e60463349db772ba0c635"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a244cd333d19e60463349db772ba0c635">buildPaths</a> (const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;paths, BuildMode buildMode=bmNormal, std::shared_ptr&lt; <a class="el" href="classnix_1_1Store.html">Store</a> &gt; evalStore=nullptr)</td></tr>
<tr class="separator:a244cd333d19e60463349db772ba0c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fadc6759038a8232dc5530812e7ad3" id="r_ad4fadc6759038a8232dc5530812e7ad3"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::vector&lt; <a class="el" href="structnix_1_1KeyedBuildResult.html">KeyedBuildResult</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4fadc6759038a8232dc5530812e7ad3">buildPathsWithResults</a> (const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;paths, BuildMode buildMode=bmNormal, std::shared_ptr&lt; <a class="el" href="classnix_1_1Store.html">Store</a> &gt; evalStore=nullptr)</td></tr>
<tr class="separator:ad4fadc6759038a8232dc5530812e7ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7affb32c7c7e52f38980ace3ce576b89" id="r_a7affb32c7c7e52f38980ace3ce576b89"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1BuildResult.html">BuildResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7affb32c7c7e52f38980ace3ce576b89">buildDerivation</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;drvPath, const <a class="el" href="structnix_1_1BasicDerivation.html">BasicDerivation</a> &amp;drv, BuildMode buildMode=bmNormal)</td></tr>
<tr class="separator:a7affb32c7c7e52f38980ace3ce576b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c937776431e45a5a0b97ccd6783bb9" id="r_a35c937776431e45a5a0b97ccd6783bb9"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35c937776431e45a5a0b97ccd6783bb9">ensurePath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a35c937776431e45a5a0b97ccd6783bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa802120d17f79dda8f8e7af4da349b7c" id="r_aa802120d17f79dda8f8e7af4da349b7c"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa802120d17f79dda8f8e7af4da349b7c">addTempRoot</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:aa802120d17f79dda8f8e7af4da349b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addda66feff338f048836bfe80de406ca" id="r_addda66feff338f048836bfe80de406ca"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addda66feff338f048836bfe80de406ca">makeValidityRegistration</a> (const StorePathSet &amp;paths, bool showDerivers, bool showHash)</td></tr>
<tr class="separator:addda66feff338f048836bfe80de406ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739866cec101a5fba91e72ca51c16c38" id="r_a739866cec101a5fba91e72ca51c16c38"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; JSON &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a739866cec101a5fba91e72ca51c16c38">pathInfoToJSON</a> (const StorePathSet &amp;storePaths, bool includeImpureInfo, bool showClosureSize, Base hashBase=Base::Base32, AllowInvalidFlag allowInvalid=DisallowInvalid)</td></tr>
<tr class="separator:a739866cec101a5fba91e72ca51c16c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cd0209c2410af651656a66bbe6105c" id="r_ab2cd0209c2410af651656a66bbe6105c"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; std::pair&lt; uint64_t, uint64_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2cd0209c2410af651656a66bbe6105c">getClosureSize</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;storePath)</td></tr>
<tr class="separator:ab2cd0209c2410af651656a66bbe6105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512573f0aacc1ef9cdb0add7ca603488" id="r_a512573f0aacc1ef9cdb0add7ca603488"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a512573f0aacc1ef9cdb0add7ca603488">optimiseStore</a> ()</td></tr>
<tr class="separator:a512573f0aacc1ef9cdb0add7ca603488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8a5bda2e4455e95c241f850672b722" id="r_a2e8a5bda2e4455e95c241f850672b722"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e8a5bda2e4455e95c241f850672b722">verifyStore</a> (bool checkContents, RepairFlag repair=NoRepair)</td></tr>
<tr class="separator:a2e8a5bda2e4455e95c241f850672b722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa651cd1f163a699c41b80a835d99a762" id="r_aa651cd1f163a699c41b80a835d99a762"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnix_1_1ref.html">ref</a>&lt; <a class="el" href="classnix_1_1FSAccessor.html">FSAccessor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa651cd1f163a699c41b80a835d99a762">getFSAccessor</a> ()=0</td></tr>
<tr class="separator:aa651cd1f163a699c41b80a835d99a762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5790dc114180dce23b412fdfd1f11231" id="r_a5790dc114180dce23b412fdfd1f11231"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5790dc114180dce23b412fdfd1f11231">repairPath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:a5790dc114180dce23b412fdfd1f11231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc18089921f9ced749535ba483cd7ace" id="r_adc18089921f9ced749535ba483cd7ace"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc18089921f9ced749535ba483cd7ace">addSignatures</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;storePath, const StringSet &amp;sigs)</td></tr>
<tr class="separator:adc18089921f9ced749535ba483cd7ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f6c8e08207c53aec33adb27f198135" id="r_a61f6c8e08207c53aec33adb27f198135"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f6c8e08207c53aec33adb27f198135">derivationFromPath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;drvPath)</td></tr>
<tr class="separator:a61f6c8e08207c53aec33adb27f198135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309c37f4356be8e1f25ef6619bf2d964" id="r_a309c37f4356be8e1f25ef6619bf2d964"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a309c37f4356be8e1f25ef6619bf2d964">readDerivation</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;drvPath)</td></tr>
<tr class="separator:a309c37f4356be8e1f25ef6619bf2d964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a12fdb30bfc05d0630889ce1a9ef26" id="r_a61a12fdb30bfc05d0630889ce1a9ef26"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a12fdb30bfc05d0630889ce1a9ef26">readInvalidDerivation</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;drvPath)</td></tr>
<tr class="separator:a61a12fdb30bfc05d0630889ce1a9ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba5295bd3a016a5ed9a7020e93dc72e" id="r_aeba5295bd3a016a5ed9a7020e93dc72e"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeba5295bd3a016a5ed9a7020e93dc72e">computeFSClosure</a> (const StorePathSet &amp;paths, StorePathSet &amp;out, bool flipDirection=false, bool includeOutputs=false, bool includeDerivers=false)</td></tr>
<tr class="separator:aeba5295bd3a016a5ed9a7020e93dc72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e36f522244d24618aae1256babcd4a" id="r_ad3e36f522244d24618aae1256babcd4a"><td class="memItemLeft" align="right" valign="top"><a id="ad3e36f522244d24618aae1256babcd4a" name="ad3e36f522244d24618aae1256babcd4a"></a>
kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>computeFSClosure</b> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path, StorePathSet &amp;out, bool flipDirection=false, bool includeOutputs=false, bool includeDerivers=false)</td></tr>
<tr class="separator:ad3e36f522244d24618aae1256babcd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d133a4cdaa811d75835a1cc61941d99" id="r_a2d133a4cdaa811d75835a1cc61941d99"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d133a4cdaa811d75835a1cc61941d99">queryMissing</a> (const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;targets, StorePathSet &amp;willBuild, StorePathSet &amp;willSubstitute, StorePathSet &amp;unknown, uint64_t &amp;downloadSize, uint64_t &amp;narSize)</td></tr>
<tr class="separator:a2d133a4cdaa811d75835a1cc61941d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aec8a2878825bfc4de7102fcff286f5" id="r_a8aec8a2878825bfc4de7102fcff286f5"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; StorePaths &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8aec8a2878825bfc4de7102fcff286f5">topoSortPaths</a> (const StorePathSet &amp;paths)</td></tr>
<tr class="separator:a8aec8a2878825bfc4de7102fcff286f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf7fab3368773453e8567489ad780c6" id="r_aeaf7fab3368773453e8567489ad780c6"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaf7fab3368773453e8567489ad780c6">exportPaths</a> (const StorePathSet &amp;paths, <a class="el" href="structnix_1_1Sink.html">Sink</a> &amp;sink)</td></tr>
<tr class="separator:aeaf7fab3368773453e8567489ad780c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddf1d5d41da55ee9312e28463335b86" id="r_a4ddf1d5d41da55ee9312e28463335b86"><td class="memItemLeft" align="right" valign="top"><a id="a4ddf1d5d41da55ee9312e28463335b86" name="a4ddf1d5d41da55ee9312e28463335b86"></a>
kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exportPath</b> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path, <a class="el" href="structnix_1_1Sink.html">Sink</a> &amp;sink)</td></tr>
<tr class="separator:a4ddf1d5d41da55ee9312e28463335b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a1ead68c8bca607d8373ae85573eca" id="r_ab3a1ead68c8bca607d8373ae85573eca"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; StorePaths &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3a1ead68c8bca607d8373ae85573eca">importPaths</a> (<a class="el" href="structnix_1_1Source.html">Source</a> &amp;source, CheckSigsFlag checkSigs=CheckSigs)</td></tr>
<tr class="separator:ab3a1ead68c8bca607d8373ae85573eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648973e66d83995ff62fdcf61d204e85" id="r_a648973e66d83995ff62fdcf61d204e85"><td class="memItemLeft" align="right" valign="top"><a id="a648973e66d83995ff62fdcf61d204e85" name="a648973e66d83995ff62fdcf61d204e85"></a>
kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Store_1_1Stats.html">Stats</a>&lt;&gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getStats</b> ()</td></tr>
<tr class="separator:a648973e66d83995ff62fdcf61d204e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278e9a96dd71825c05c40f93c6fc9cff" id="r_a278e9a96dd71825c05c40f93c6fc9cff"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; StorePathSet &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a278e9a96dd71825c05c40f93c6fc9cff">exportReferences</a> (const StorePathSet &amp;storePaths, const StorePathSet &amp;inputPaths)</td></tr>
<tr class="separator:a278e9a96dd71825c05c40f93c6fc9cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8f50f2a0d3bde8c893a61d80ce383d" id="r_a2e8f50f2a0d3bde8c893a61d80ce383d"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; Result&lt; std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e8f50f2a0d3bde8c893a61d80ce383d">getBuildDerivationPath</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;)</td></tr>
<tr class="separator:a2e8f50f2a0d3bde8c893a61d80ce383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1cf7a9a7357d390af3f4180ee80f53" id="r_a6b1cf7a9a7357d390af3f4180ee80f53"><td class="memItemLeft" align="right" valign="top">kj::Promise&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1cf7a9a7357d390af3f4180ee80f53">clearPathInfoCache</a> ()</td></tr>
<tr class="separator:a6b1cf7a9a7357d390af3f4180ee80f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaa64c15cbb92cddf6cf948236d82dd" id="r_aacaa64c15cbb92cddf6cf948236d82dd"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacaa64c15cbb92cddf6cf948236d82dd">connect</a> ()</td></tr>
<tr class="separator:aacaa64c15cbb92cddf6cf948236d82dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763d0da5566011acfbd50fd05c8c1f29" id="r_a763d0da5566011acfbd50fd05c8c1f29"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a763d0da5566011acfbd50fd05c8c1f29">getProtocol</a> ()</td></tr>
<tr class="separator:a763d0da5566011acfbd50fd05c8c1f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf848840fbe0813c2120055591f85ae" id="r_a9bf848840fbe0813c2120055591f85ae"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::optional&lt; TrustedFlag &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf848840fbe0813c2120055591f85ae">isTrustedClient</a> ()=0</td></tr>
<tr class="separator:a9bf848840fbe0813c2120055591f85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52dac037b7a4996af5e22008d579049" id="r_af52dac037b7a4996af5e22008d579049"><td class="memItemLeft" align="right" valign="top"><a id="af52dac037b7a4996af5e22008d579049" name="af52dac037b7a4996af5e22008d579049"></a>
virtual <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toRealPath</b> (const <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &amp;storePath)</td></tr>
<tr class="separator:af52dac037b7a4996af5e22008d579049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b500ff85686bc5d35aa46a9514fec12" id="r_a3b500ff85686bc5d35aa46a9514fec12"><td class="memItemLeft" align="right" valign="top"><a id="a3b500ff85686bc5d35aa46a9514fec12" name="a3b500ff85686bc5d35aa46a9514fec12"></a>
<a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><b>toRealPath</b> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;storePath)</td></tr>
<tr class="separator:a3b500ff85686bc5d35aa46a9514fec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa195b57330d42b44b692b3900000ef79" id="r_aa195b57330d42b44b692b3900000ef79"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa195b57330d42b44b692b3900000ef79">setOptions</a> ()</td></tr>
<tr class="separator:aa195b57330d42b44b692b3900000ef79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31589bc5b8a72457e11aa9e0ecd501cb" id="r_a31589bc5b8a72457e11aa9e0ecd501cb"><td class="memItemLeft" align="right" valign="top"><a id="a31589bc5b8a72457e11aa9e0ecd501cb" name="a31589bc5b8a72457e11aa9e0ecd501cb"></a>
virtual kj::Promise&lt; Result&lt; std::optional&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVersion</b> ()</td></tr>
<tr class="separator:a31589bc5b8a72457e11aa9e0ecd501cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a06ff179fe55c3f2d6eeac63d9fcb18a4" id="r_a06ff179fe55c3f2d6eeac63d9fcb18a4"><td class="memItemLeft" align="right" valign="top"><a id="a06ff179fe55c3f2d6eeac63d9fcb18a4" name="a06ff179fe55c3f2d6eeac63d9fcb18a4"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>MissingName</b> = &quot;x&quot;</td></tr>
<tr class="separator:a06ff179fe55c3f2d6eeac63d9fcb18a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a72c62a1391fc1f8941a824e54fb21647" id="r_a72c62a1391fc1f8941a824e54fb21647"><td class="memItemLeft" align="right" valign="top"><a id="a72c62a1391fc1f8941a824e54fb21647" name="a72c62a1391fc1f8941a824e54fb21647"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Store</b> (const <a class="el" href="structnix_1_1StoreConfig.html">StoreConfig</a> &amp;config)</td></tr>
<tr class="separator:a72c62a1391fc1f8941a824e54fb21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ab9f5645031be0568aca13d372cf18" id="r_ab7ab9f5645031be0568aca13d372cf18"><td class="memItemLeft" align="right" valign="top"><a id="ab7ab9f5645031be0568aca13d372cf18" name="ab7ab9f5645031be0568aca13d372cf18"></a>
virtual kj::Promise&lt; Result&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>isValidPathUncached</b> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)</td></tr>
<tr class="separator:ab7ab9f5645031be0568aca13d372cf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa634a17855af0aad485087e32bc6adb4" id="r_aa634a17855af0aad485087e32bc6adb4"><td class="memItemLeft" align="right" valign="top">virtual kj::Promise&lt; Result&lt; std::shared_ptr&lt; const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa634a17855af0aad485087e32bc6adb4">queryPathInfoUncached</a> (const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;path)=0</td></tr>
<tr class="separator:aa634a17855af0aad485087e32bc6adb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe400863b5e76584d0d385bc816ad4da" id="r_abe400863b5e76584d0d385bc816ad4da"><td class="memItemLeft" align="right" valign="top"><a id="abe400863b5e76584d0d385bc816ad4da" name="abe400863b5e76584d0d385bc816ad4da"></a>
virtual kj::Promise&lt; Result&lt; std::shared_ptr&lt; const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>queryRealisationUncached</b> (const <a class="el" href="structnix_1_1DrvOutput.html">DrvOutput</a> &amp;)=0</td></tr>
<tr class="separator:abe400863b5e76584d0d385bc816ad4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88896cc85fd41e13c705ae7d430681a" id="r_ae88896cc85fd41e13c705ae7d430681a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88896cc85fd41e13c705ae7d430681a">unsupported</a> (const std::string &amp;op)</td></tr>
<tr class="separator:ae88896cc85fd41e13c705ae7d430681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa5383c7bd4e1ab63d62b90d5a8027832" id="r_aa5383c7bd4e1ab63d62b90d5a8027832"><td class="memItemLeft" align="right" valign="top"><a id="aa5383c7bd4e1ab63d62b90d5a8027832" name="aa5383c7bd4e1ab63d62b90d5a8027832"></a>
<a class="el" href="classnix_1_1Sync.html">Sync</a>&lt; <a class="el" href="structnix_1_1Store_1_1State.html">State</a>, AsyncMutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>state</b></td></tr>
<tr class="separator:aa5383c7bd4e1ab63d62b90d5a8027832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5796eb426060f956a726792e9c7e9894" id="r_a5796eb426060f956a726792e9c7e9894"><td class="memItemLeft" align="right" valign="top"><a id="a5796eb426060f956a726792e9c7e9894" name="a5796eb426060f956a726792e9c7e9894"></a>
std::shared_ptr&lt; <a class="el" href="classnix_1_1NarInfoDiskCache.html">NarInfoDiskCache</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>diskCache</b></td></tr>
<tr class="separator:a5796eb426060f956a726792e9c7e9894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab62cd90a1c0b60d266f6eb069bd693" id="r_adab62cd90a1c0b60d266f6eb069bd693"><td class="memItemLeft" align="right" valign="top"><a id="adab62cd90a1c0b60d266f6eb069bd693" name="adab62cd90a1c0b60d266f6eb069bd693"></a>
<a class="el" href="structnix_1_1Store_1_1Stats.html">Stats</a>&lt; std::atomic &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:adab62cd90a1c0b60d266f6eb069bd693"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aed97c14118868d419851977844ed4f96" name="aed97c14118868d419851977844ed4f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed97c14118868d419851977844ed4f96">&#9670;&#160;</a></span>PathsSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aed97c14118868d419851977844ed4f96">nix::Store::PathsSource</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::vector&lt;</div>
<div class="line">        std::pair&lt;ValidPathInfo, std::function&lt;kj::Promise&lt;Result&lt;box_ptr&lt;AsyncInputStream&gt;&gt;&gt;()&gt;&gt;&gt;</div>
</div><!-- fragment --><p>A list of paths infos along with a source providing the content of the associated store path </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf383c87b0ad7d323783291bd3bf5e64" name="acf383c87b0ad7d323783291bd3bf5e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf383c87b0ad7d323783291bd3bf5e64">&#9670;&#160;</a></span>addMultipleToStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::addMultipleToStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed97c14118868d419851977844ed4f96">PathsSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pathsToCopy</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnix_1_1Activity.html">Activity</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>act</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CheckSigsFlag</td>          <td class="paramname"><span class="paramname"><em>checkSigs</em><span class="paramdefsep"> = </span><span class="paramdefval">CheckSigs</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import multiple paths into the store. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1RemoteStore.html#a7e2655e20ccce7c9d66585cfbbdec174">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="adc18089921f9ced749535ba483cd7ace" name="adc18089921f9ced749535ba483cd7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc18089921f9ced749535ba483cd7ace">&#9670;&#160;</a></span>addSignatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::addSignatures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>storePath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringSet &amp;</td>          <td class="paramname"><span class="paramname"><em>sigs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add signatures to the specified store path. The signatures are not verified. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a7c6b14b3652595ec6cefd2eb762cbfe5">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a7fbc6c279540b256324186332ed6895b">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a23ba41eb8a053cbc9e55f105ee32c25e">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#ab35661f70c9415f671e8b75859448f11">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="aa802120d17f79dda8f8e7af4da349b7c" name="aa802120d17f79dda8f8e7af4da349b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa802120d17f79dda8f8e7af4da349b7c">&#9670;&#160;</a></span>addTempRoot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::addTempRoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a store path as a temporary root of the garbage collector. The root disappears as soon as we exit. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#adab72e09d147bb0186c0462b45e40bf4">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalStore.html#aed2043e9886133a78fcbc751c6f898f2">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a656fe580ac6601e433aec9c7967a2c18">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="ab9a1e14d0bfac487c6886b3184009f7f" name="ab9a1e14d0bfac487c6886b3184009f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a1e14d0bfac487c6886b3184009f7f">&#9670;&#160;</a></span>addTextToStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; nix::Store::addTextToStore </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>references</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like addToStore, but the contents written to the output path is a regular file containing the given string. </p>

<p>Implemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a312e0c8c454fad49d222012d00552fde">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a7813df7ad483ce001dd709ed93cb72cc">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a938feb7faceb796a8bd90e9034e409dd">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a6ca988f60117772371a779ff72ea376d">nix::LocalStore</a>, <a class="el" href="classnix_1_1RemoteStore.html#a2e11b602ce1151f5cede77cc21630608">nix::RemoteStore</a>, and <a class="el" href="structnix_1_1RestrictedStore.html#a230537b1c74c958257291b95a4d62c2e">nix::RestrictedStore</a>.</p>

</div>
</div>
<a id="ac08e3a945634557d90840c3e178bdbea" name="ac08e3a945634557d90840c3e178bdbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e3a945634557d90840c3e178bdbea">&#9670;&#160;</a></span>addToStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::addToStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>info</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnix_1_1AsyncInputStream.html">AsyncInputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>narSource</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CheckSigsFlag</td>          <td class="paramname"><span class="paramname"><em>checkSigs</em><span class="paramdefsep"> = </span><span class="paramdefval">CheckSigs</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import a path into the store. </p>

<p>Implemented in <a class="el" href="classnix_1_1RemoteStore.html#a3862baab27b6c201ca9aece7e090ab20">nix::RemoteStore</a>, <a class="el" href="classnix_1_1BinaryCacheStore.html#ad4585d08654c1e23af900af264eb409a">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a7b105df4c7393d65ec4d7f812b657848">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1DummyStore.html#ac51f9ec0ab2bd89734d57d38e1d76641">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a0b05f1d65ef2105e44b51ed87419ddf3">nix::LegacySSHStore</a>, and <a class="el" href="classnix_1_1LocalStore.html#a465ae7a2e855d06008f129c5e5d998ce">nix::LocalStore</a>.</p>

</div>
</div>
<a id="a62b847754a469ff071e3c49f611a3746" name="a62b847754a469ff071e3c49f611a3746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b847754a469ff071e3c49f611a3746">&#9670;&#160;</a></span>addToStoreFromDump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; nix::Store::addToStoreFromDump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnix_1_1AsyncInputStream.html">AsyncInputStream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dump</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cd">FileIngestionMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cda556c3dd912453ae5cb3095cd5054e6f4">FileIngestionMethod::Recursive</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashType</td>          <td class="paramname"><span class="paramname"><em>hashAlgo</em><span class="paramdefsep"> = </span><span class="paramdefval">HashType::SHA256</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>references</em><span class="paramdefsep"> = </span><span class="paramdefval">StorePathSet()</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="#ac08e3a945634557d90840c3e178bdbea">addToStore()</a>, but the contents of the path are contained in <code>dump</code>, which is either a NAR serialisation (if recursive == true) or simply the contents of a regular file (if recursive == false). <code>dump</code> may be drained</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo</a></b></dt><dd>remove? </dd></dl>

<p>Reimplemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a2281d28f2941ab70068b92b9405a7415">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a2695538d76a602d81b5685605d88142c">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalStore.html#aebd57f7f08c6741cc7be5cab3d2d92ad">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#ab6901f5693a67a90a1997a3199c57ac9">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a305a1a0e32afb0999df11b1d0731a6fd" name="a305a1a0e32afb0999df11b1d0731a6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305a1a0e32afb0999df11b1d0731a6fd">&#9670;&#160;</a></span>addToStoreRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; nix::Store::addToStoreRecursive </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnix_1_1PreparedDump.html">PreparedDump</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashType</td>          <td class="paramname"><span class="paramname"><em>hashAlgo</em><span class="paramdefsep"> = </span><span class="paramdefval">HashType::SHA256</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the contents of a path to the store and register the validity the resulting path.</p>
<dl class="section return"><dt>Returns</dt><dd>The resulting path is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>This function can be used to exclude files (see <a class="el" href="archive_8hh.html">libutil/archive.hh</a>). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a38e02e10674787551540137f1c8bfd49">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a6e20cee4e8cb16e109622bcc34f1f631">nix::RestrictedStore</a>, and <a class="el" href="structnix_1_1LegacySSHStore.html#a223f13233f62ee39a36d34fa5dbde6a7">nix::LegacySSHStore</a>.</p>

</div>
</div>
<a id="a650aeb5d0fd2b808e75d7f0da2e5d5ef" name="a650aeb5d0fd2b808e75d7f0da2e5d5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650aeb5d0fd2b808e75d7f0da2e5d5ef">&#9670;&#160;</a></span>addToStoreSlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt; nix::Store::addToStoreSlow </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcPath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cd">FileIngestionMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="content-address_8hh.html#ae9b0bff1b6ec5d32e6ce92870d9b14cda556c3dd912453ae5cb3095cd5054e6f4">FileIngestionMethod::Recursive</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HashType</td>          <td class="paramname"><span class="paramname"><em>hashAlgo</em><span class="paramdefsep"> = </span><span class="paramdefval">HashType::SHA256</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="structnix_1_1Hash.html">Hash</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expectedCAHash</em><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the contents of a path to the store and register the validity the resulting path, using a constant amount of memory. </p>

</div>
</div>
<a id="a7affb32c7c7e52f38980ace3ce576b89" name="a7affb32c7c7e52f38980ace3ce576b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7affb32c7c7e52f38980ace3ce576b89">&#9670;&#160;</a></span>buildDerivation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1BuildResult.html">BuildResult</a> &gt; &gt; nix::Store::buildDerivation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drvPath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnix_1_1BasicDerivation.html">BasicDerivation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drv</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BuildMode</td>          <td class="paramname"><span class="paramname"><em>buildMode</em><span class="paramdefsep"> = </span><span class="paramdefval">bmNormal</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Build a single non-materialized derivation (i.e. not from an on-disk .drv file).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drvPath</td><td>This is used to deduplicate worker goals so it is imperative that is correct. That said, it doesn't literally need to be store path that would be calculated from writing this derivation to the store: it is OK if it instead is that of a <a class="el" href="structnix_1_1Derivation.html">Derivation</a> which would resolve to this (by taking the outputs of it's input derivations and adding them as input sources) such that the build time referenceable-paths are the same.</td></tr>
  </table>
  </dd>
</dl>
<p>In the input-addressed case, we usually <em>do</em> use an "original" unresolved derivations's path, as that is what will be used in the buildPaths case. Also, the input-addressed output paths are verified only by that contents of that specific unresolved derivation, so it is nice to keep that information around so if the original derivation is ever obtained later, it can be verified whether the trusted user in fact used the proper output path.</p>
<p>In the content-addressed case, we want to always use the resolved drv path calculated from the provided derivation. This serves two purposes:</p>
<ul>
<li>It keeps the operation trustless, by ruling out a maliciously invalid drv path corresponding to a non-resolution-equivalent derivation.</li>
<li>For the floating case in particular, it ensures that the derivation to output mapping respects the resolution equivalence relation, so one cannot choose different resolution-equivalent derivations to subvert dependency coherence (i.e. the property that one doesn't end up with multiple different versions of dependencies without explicitly choosing to allow it). </li>
</ul>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a2b2647becacfe4a7d3745a4495ec5eaf">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1RemoteStore.html#a8a483f8b5f3fe66bcbdabe5ffbb9692e">nix::RemoteStore</a>, and <a class="el" href="structnix_1_1RestrictedStore.html#ae9e9b73ab335a507ac68c0e9e2c8c48b">nix::RestrictedStore</a>.</p>

</div>
</div>
<a id="a244cd333d19e60463349db772ba0c635" name="a244cd333d19e60463349db772ba0c635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244cd333d19e60463349db772ba0c635">&#9670;&#160;</a></span>buildPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::buildPaths </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BuildMode</td>          <td class="paramname"><span class="paramname"><em>buildMode</em><span class="paramdefsep"> = </span><span class="paramdefval">bmNormal</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classnix_1_1Store.html">Store</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>evalStore</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each path, if it's a derivation, build it. Building a derivation means ensuring that the output paths are valid. If they are already valid, this is a no-op. Otherwise, validity can be reached in two ways. First, if the output paths is substitutable, then build the path that way. Second, the output paths can be created by running the builder, after recursively building any sub-derivations. For inputs that are not derivations, substitute them. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a8af7b9c59b4ca233040c24b3b6326bea">nix::LegacySSHStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a68b15d5d7013b7fce0fe543c28dcdffd">nix::RestrictedStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a58fb41456a76cff48bde4c296bb0bf4a">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="ad4fadc6759038a8232dc5530812e7ad3" name="ad4fadc6759038a8232dc5530812e7ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fadc6759038a8232dc5530812e7ad3">&#9670;&#160;</a></span>buildPathsWithResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::vector&lt; <a class="el" href="structnix_1_1KeyedBuildResult.html">KeyedBuildResult</a> &gt; &gt; &gt; nix::Store::buildPathsWithResults </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BuildMode</td>          <td class="paramname"><span class="paramname"><em>buildMode</em><span class="paramdefsep"> = </span><span class="paramdefval">bmNormal</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classnix_1_1Store.html">Store</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>evalStore</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="#a244cd333d19e60463349db772ba0c635">buildPaths()</a>, but return a vector of <a class="el" href="structnix_1_1BuildResult.html">BuildResult</a> BuildResults corresponding to each element in paths. Note that in case of a build/substitution error, this function won't throw an exception, but return a <a class="el" href="structnix_1_1BuildResult.html">BuildResult</a> containing an error message. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1RemoteStore.html#aea7706cc261c5a54faaba9c7bb54dfee">nix::RemoteStore</a>, and <a class="el" href="structnix_1_1RestrictedStore.html#aabf26b37d4155ace8920b6b9a63ea9ed">nix::RestrictedStore</a>.</p>

</div>
</div>
<a id="a6b1cf7a9a7357d390af3f4180ee80f53" name="a6b1cf7a9a7357d390af3f4180ee80f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1cf7a9a7357d390af3f4180ee80f53">&#9670;&#160;</a></span>clearPathInfoCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; void &gt; nix::Store::clearPathInfoCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hack to allow long-running processes like hydra-queue-runner to occasionally flush their path info cache. </p>

</div>
</div>
<a id="aeba5295bd3a016a5ed9a7020e93dc72e" name="aeba5295bd3a016a5ed9a7020e93dc72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba5295bd3a016a5ed9a7020e93dc72e">&#9670;&#160;</a></span>computeFSClosure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::computeFSClosure </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flipDirection</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeOutputs</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeDerivers</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Place in here the set of all store paths in the file system closure of <code>storePath</code>; that is, all paths than can be directly or indirectly reached from it. <code>out</code> is not cleared.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flipDirection</td><td>If true, the set of paths that can reach <code>storePath</code> is returned; that is, the closures under the <code>referrers</code> relation instead of the <code>references</code> relation is returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a0e9a19148a30e507c57e5a14c8dbd62a">nix::LegacySSHStore</a>.</p>

</div>
</div>
<a id="af4ba656626eada43819c054fe04e7036" name="af4ba656626eada43819c054fe04e7036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ba656626eada43819c054fe04e7036">&#9670;&#160;</a></span>computeStorePathForPathRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnix_1_1StorePath.html">StorePath</a> nix::Store::computeStorePathForPathRecursive </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnix_1_1PreparedDump.html">PreparedDump</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preparatory part of <a class="el" href="#ac08e3a945634557d90840c3e178bdbea">addToStore()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the store path to which srcPath is to be copied. </dd></dl>

</div>
</div>
<a id="ab95a74ca6373fc7fb2b1028b70073f71" name="ab95a74ca6373fc7fb2b1028b70073f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95a74ca6373fc7fb2b1028b70073f71">&#9670;&#160;</a></span>computeStorePathForText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnix_1_1StorePath.html">StorePath</a> nix::Store::computeStorePathForText </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>references</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preparatory part of <a class="el" href="#ab9a1e14d0bfac487c6886b3184009f7f">addTextToStore()</a>.</p>
<p>!!! Computation of the path should take the references given to <a class="el" href="#ab9a1e14d0bfac487c6886b3184009f7f">addTextToStore()</a> into account, otherwise we have a (relatively minor) security hole: a caller can register a source file with bogus references. If there are too many references, the path may not be garbage collected when it has to be (not really a problem, the caller could create a root anyway), or it may be garbage collected when it shouldn't be (more serious).</p>
<p>Hashing the references would solve this (bogus references would simply yield a different store path, so other users wouldn't be affected), but it has some backwards compatibility issues (the hashing scheme changes), so I'm not doing that for now. </p>

</div>
</div>
<a id="aacaa64c15cbb92cddf6cf948236d82dd" name="aacaa64c15cbb92cddf6cf948236d82dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaa64c15cbb92cddf6cf948236d82dd">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::connect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Establish a connection to the store, for store types that have a notion of connection. Otherwise this is a no-op. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a98f121b0a520cb73bfc55c39f67590a9">nix::LegacySSHStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a2e1d5d339c418c69e8142c63834489bc">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a61f6c8e08207c53aec33adb27f198135" name="a61f6c8e08207c53aec33adb27f198135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f6c8e08207c53aec33adb27f198135">&#9670;&#160;</a></span>derivationFromPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt; nix::Store::derivationFromPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drvPath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a derivation, after ensuring its existence through <a class="el" href="#a35c937776431e45a5a0b97ccd6783bb9">ensurePath()</a>. </p>

</div>
</div>
<a id="a35c937776431e45a5a0b97ccd6783bb9" name="a35c937776431e45a5a0b97ccd6783bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c937776431e45a5a0b97ccd6783bb9">&#9670;&#160;</a></span>ensurePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::ensurePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that a path is valid. If it is not currently valid, it may be made valid by running a substitute (if defined for the path). </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#aa0969524e8962edf5dfe848d4c767946">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#ae305b4390086799954bc8a1c11f36427">nix::LegacySSHStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a73aa3b5ccf5d817b4f9511481849bc36">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="aeaf7fab3368773453e8567489ad780c6" name="aeaf7fab3368773453e8567489ad780c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf7fab3368773453e8567489ad780c6">&#9670;&#160;</a></span>exportPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::exportPaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnix_1_1Sink.html">Sink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export multiple paths in the format expected by ‘nix-store &ndash;import’. </p>

</div>
</div>
<a id="a278e9a96dd71825c05c40f93c6fc9cff" name="a278e9a96dd71825c05c40f93c6fc9cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278e9a96dd71825c05c40f93c6fc9cff">&#9670;&#160;</a></span>exportReferences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::exportReferences </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>storePaths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>inputPaths</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the full closure of of a set of store-paths for e.g. derivations that need this information for <code>exportReferencesGraph</code>. </p>

</div>
</div>
<a id="a900ae582df895315fc7001c03806e939" name="a900ae582df895315fc7001c03806e939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a900ae582df895315fc7001c03806e939">&#9670;&#160;</a></span>followLinksToStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> nix::Store::followLinksToStore </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Follow symlinks until we end up with a path in the Nix store. </p>

</div>
</div>
<a id="a5f5320ff7f00646d88edf09443dfae2d" name="a5f5320ff7f00646d88edf09443dfae2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5320ff7f00646d88edf09443dfae2d">&#9670;&#160;</a></span>followLinksToStorePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnix_1_1StorePath.html">StorePath</a> nix::Store::followLinksToStorePath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#a900ae582df895315fc7001c03806e939">followLinksToStore()</a>, but apply <a class="el" href="#af964f508806321bde6423c52a2634671">toStorePath()</a> to the result. </p>

</div>
</div>
<a id="a2e8f50f2a0d3bde8c893a61d80ce383d" name="a2e8f50f2a0d3bde8c893a61d80ce383d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8f50f2a0d3bde8c893a61d80ce383d">&#9670;&#160;</a></span>getBuildDerivationPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; nix::Store::getBuildDerivationPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a store path, return the realisation actually used in the realisation of this path:</p><ul>
<li>If the path is a content-addressed derivation, try to resolve it</li>
<li>Otherwise, find one of its derivers </li>
</ul>

</div>
</div>
<a id="ab2cd0209c2410af651656a66bbe6105c" name="ab2cd0209c2410af651656a66bbe6105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cd0209c2410af651656a66bbe6105c">&#9670;&#160;</a></span>getClosureSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::pair&lt; uint64_t, uint64_t &gt; &gt; &gt; nix::Store::getClosureSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>storePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the closure of the specified path, that is, the sum of the size of the NAR serialisation of each path in the closure. </dd></dl>

</div>
</div>
<a id="aa651cd1f163a699c41b80a835d99a762" name="aa651cd1f163a699c41b80a835d99a762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa651cd1f163a699c41b80a835d99a762">&#9670;&#160;</a></span>getFSAccessor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnix_1_1ref.html">ref</a>&lt; <a class="el" href="classnix_1_1FSAccessor.html">FSAccessor</a> &gt; nix::Store::getFSAccessor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An object to access files in the Nix store. </dd></dl>

<p>Implemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a7fae96a1485992581caae4df36c67216">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a1fbb3ac0eb5bdec5f7874fd6060dc8c8">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#aca16a9391670eabcfd8ee44e51e74a31">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalFSStore.html#adc508cf3eb38a7906bd54c46c7b21921">nix::LocalFSStore</a>, <a class="el" href="classnix_1_1RemoteStore.html#a127adda83a8c2908763951cb1fe6667f">nix::RemoteStore</a>, and <a class="el" href="classnix_1_1UDSRemoteStore.html#a47a3ad847a4bac230bb30f57e45499f1">nix::UDSRemoteStore</a>.</p>

</div>
</div>
<a id="a763d0da5566011acfbd50fd05c8c1f29" name="a763d0da5566011acfbd50fd05c8c1f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763d0da5566011acfbd50fd05c8c1f29">&#9670;&#160;</a></span>getProtocol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; unsigned int &gt; &gt; nix::Store::getProtocol </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the protocol version of this store or it's connection. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a069a79da900d6badac2ed7ed1c101c9a">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a0cb23d9d02d56f32afbeb5713736aeab">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a6e5e8ed73ba6dcc8d64fbd56ec029f9e">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a08cff065f2af74517c34321a4373f649" name="a08cff065f2af74517c34321a4373f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cff065f2af74517c34321a4373f649">&#9670;&#160;</a></span>getUri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string nix::Store::getUri </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classnix_1_1LocalStore.html#a14e45faed56142d6d177c83204548055">nix::LocalStore</a>.</p>

</div>
</div>
<a id="ab3a1ead68c8bca607d8373ae85573eca" name="ab3a1ead68c8bca607d8373ae85573eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a1ead68c8bca607d8373ae85573eca">&#9670;&#160;</a></span>importPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; StorePaths &gt; &gt; nix::Store::importPaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnix_1_1Source.html">Source</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CheckSigsFlag</td>          <td class="paramname"><span class="paramname"><em>checkSigs</em><span class="paramdefsep"> = </span><span class="paramdefval">CheckSigs</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import a sequence of NAR dumps created by <a class="el" href="#aeaf7fab3368773453e8567489ad780c6">exportPaths()</a> into the Nix store. Optionally, the contents of the NARs are preloaded into the specified FS accessor to speed up subsequent access. </p>

</div>
</div>
<a id="ae5af7b0c2fd14332d3ce5db0c6761f0f" name="ae5af7b0c2fd14332d3ce5db0c6761f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5af7b0c2fd14332d3ce5db0c6761f0f">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform any necessary effectful operation to make the store up and running </p>

<p>Reimplemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#aaf99647978f328bd6366413264abeb96">nix::BinaryCacheStore</a>, <a class="el" href="classnix_1_1HttpBinaryCacheStore.html#a87775c4c49fc353aa621501327303784">nix::HttpBinaryCacheStore</a>, and <a class="el" href="classnix_1_1LocalBinaryCacheStore.html#aa48297660f77f2c453862de70f68e490">nix::LocalBinaryCacheStore</a>.</p>

</div>
</div>
<a id="ab76a077a45e877f1173ee4bc90f2e775" name="ab76a077a45e877f1173ee4bc90f2e775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76a077a45e877f1173ee4bc90f2e775">&#9670;&#160;</a></span>isInStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nix::Store::isInStore </td>
          <td>(</td>
          <td class="paramtype">PathView</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if ‘path’ is in the Nix store (but not the Nix store itself). </dd></dl>

</div>
</div>
<a id="aea7f8f6338f1b97e1ff5e6f2511d181e" name="aea7f8f6338f1b97e1ff5e6f2511d181e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7f8f6338f1b97e1ff5e6f2511d181e">&#9670;&#160;</a></span>isStorePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nix::Store::isStorePath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if ‘path’ is a store path, i.e. a direct child of the Nix store. </dd></dl>

</div>
</div>
<a id="a9bf848840fbe0813c2120055591f85ae" name="a9bf848840fbe0813c2120055591f85ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf848840fbe0813c2120055591f85ae">&#9670;&#160;</a></span>isTrustedClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; std::optional&lt; TrustedFlag &gt; &gt; &gt; nix::Store::isTrustedClient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>/ whether store trusts <em>us</em>.</dd></dl>
<p><code>std::nullopt</code> means we do not know.</p>
<dl class="section note"><dt>Note</dt><dd>This is the opposite of the StoreConfig::isTrusted store setting. That is about whether <em>we</em> trust the store. </dd></dl>

<p>Implemented in <a class="el" href="structnix_1_1RestrictedStore.html#aafd59bc04bad53ad67eec9bf2a39c258">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a5bc0abd77083303b078ca2d3388efcae">nix::DummyStore</a>, <a class="el" href="classnix_1_1HttpBinaryCacheStore.html#a9024021c6c65d2e315fdb5e0218329ba">nix::HttpBinaryCacheStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a46ffbdc287ff9f4d5fbc401ec2136966">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalBinaryCacheStore.html#a7049b1677d621f2fff6a99c037fbcdaf">nix::LocalBinaryCacheStore</a>, <a class="el" href="classnix_1_1LocalStore.html#acaafe26e530fd3fc554f05a48002a3f9">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a9fca4c019962d21cb328a976cfb9efbb">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a74d18dcc2bb3d5aca34f8ae5f6d70091" name="a74d18dcc2bb3d5aca34f8ae5f6d70091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d18dcc2bb3d5aca34f8ae5f6d70091">&#9670;&#160;</a></span>isValidPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; bool &gt; &gt; nix::Store::isValidPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a path is valid. A path is valid when it exists in the store <em>now</em>. </p>

</div>
</div>
<a id="a2b14286cafeb77a9de91491523bf7584" name="a2b14286cafeb77a9de91491523bf7584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b14286cafeb77a9de91491523bf7584">&#9670;&#160;</a></span>makeStorePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnix_1_1StorePath.html">StorePath</a> nix::Store::makeStorePath </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>hash</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a unique store path name. </p>

</div>
</div>
<a id="addda66feff338f048836bfe80de406ca" name="addda66feff338f048836bfe80de406ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addda66feff338f048836bfe80de406ca">&#9670;&#160;</a></span>makeValidityRegistration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::string &gt; &gt; nix::Store::makeValidityRegistration </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>showDerivers</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>showHash</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string representing information about the path that can be loaded into the database using <code>nix-store --load-db</code> or <code>nix-store --register-validity</code>. </dd></dl>

</div>
</div>
<a id="afdbaff078efae29478dc8e29497e9d39" name="afdbaff078efae29478dc8e29497e9d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbaff078efae29478dc8e29497e9d39">&#9670;&#160;</a></span>narFromPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1box__ptr.html">box_ptr</a>&lt; <a class="el" href="structnix_1_1Source.html">Source</a> &gt; &gt; &gt; nix::Store::narFromPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a NAR dump of a store path. </p>

<p>Implemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#ab0153695a4012072b10a57a72842798d">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#acda1fbf6cd06c04383644be385d3271e">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a4c41684cedc380e2aa1ba9ef6ec3b491">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a3ead25b0907c409672c13fb004a04905">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalFSStore.html#a6703b5107bcf7f01fa771e48e29f404e">nix::LocalFSStore</a>, <a class="el" href="classnix_1_1RemoteStore.html#a8aee5515092b2d461d43808a108a47e8">nix::RemoteStore</a>, and <a class="el" href="classnix_1_1UDSRemoteStore.html#a13aca00f14deb3f9272e12996755321b">nix::UDSRemoteStore</a>.</p>

</div>
</div>
<a id="a512573f0aacc1ef9cdb0add7ca603488" name="a512573f0aacc1ef9cdb0add7ca603488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512573f0aacc1ef9cdb0add7ca603488">&#9670;&#160;</a></span>optimiseStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::optimiseStore </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimise the disk space usage of the Nix store by hard-linking files with the same contents. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#a4fcf7ef18689d801b3417bbe3a13f59f">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#aab1b24ce92794eaf860327ef806c0a10">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a57d5a6d2d5e933c5a0aa2f4b3a0939e3" name="a57d5a6d2d5e933c5a0aa2f4b3a0939e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d5a6d2d5e933c5a0aa2f4b3a0939e3">&#9670;&#160;</a></span>parseStorePathSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorePathSet nix::Store::parseStorePathSet </td>
          <td>(</td>
          <td class="paramtype">const PathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo</a></b></dt><dd>remove </dd></dl>

</div>
</div>
<a id="aedbd0e468eeef6e7196962ed361250ed" name="aedbd0e468eeef6e7196962ed361250ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbd0e468eeef6e7196962ed361250ed">&#9670;&#160;</a></span>pathInfoIsUntrusted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nix::Store::pathInfoIsUntrusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the given valid path info is sufficiently attested, by either being signed by a trusted public key or content-addressed, in order to be included in the given store.</p>
<p>These same checks would be performed in addToStore, but this allows an earlier failure in the case where dependencies need to be added too, but the addToStore wouldn't fail until those dependencies are added. Also, we don't really want to add the dependencies listed in a nar info we don't trust anyyways. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#a546e1db1e1c5c2660e4c27debf48af65">nix::LocalStore</a>.</p>

</div>
</div>
<a id="a739866cec101a5fba91e72ca51c16c38" name="a739866cec101a5fba91e72ca51c16c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739866cec101a5fba91e72ca51c16c38">&#9670;&#160;</a></span>pathInfoToJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; JSON &gt; &gt; nix::Store::pathInfoToJSON </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>storePaths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeImpureInfo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>showClosureSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base</td>          <td class="paramname"><span class="paramname"><em>hashBase</em><span class="paramdefsep"> = </span><span class="paramdefval">Base::Base32</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllowInvalidFlag</td>          <td class="paramname"><span class="paramname"><em>allowInvalid</em><span class="paramdefsep"> = </span><span class="paramdefval">DisallowInvalid</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a JSON representation of store path metadata, such as the hash and the references.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeImpureInfo</td><td>If true, variable elements such as the registration time are included.</td></tr>
    <tr><td class="paramname">showClosureSize</td><td>If true, the closure size of each path is included. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af107fb3d1815c8fc3711a7b2bfda0a00" name="af107fb3d1815c8fc3711a7b2bfda0a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af107fb3d1815c8fc3711a7b2bfda0a00">&#9670;&#160;</a></span>queryAllValidPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::queryAllValidPaths </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the set of all valid paths. Note that for some store backends, the name part of store paths may be replaced by 'x' (i.e. you'll get /nix/store/&lt;hash&gt;-x rather than /nix/store/&lt;hash&gt;-&lt;name&gt;). Use <a class="el" href="#a23ba8ca476aa6273f160a39f3879d9c6">queryPathInfo()</a> to obtain the full store path. FIXME: should return a set of std::variant&lt;StorePath, HashPart&gt; to get rid of this hack. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#a41cac0d49cb510518b335ceb49b89fa0">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalBinaryCacheStore.html#a1e265ddd378d683f142a3b59b37319e7">nix::LocalBinaryCacheStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a9f4e74d878b9d2bc08086252deb478cb">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a56802a2b54a6c6294e627a9e44525a8b">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="aa55907354ec2fb29435275ae794b147b" name="aa55907354ec2fb29435275ae794b147b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55907354ec2fb29435275ae794b147b">&#9670;&#160;</a></span>queryDerivationOutputMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; OutputPathMap &gt; &gt; nix::Store::queryDerivationOutputMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnix_1_1Store.html">Store</a> *</td>          <td class="paramname"><span class="paramname"><em>evalStore</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the mapping outputName=&gt;outputPath for the given derivation. Assume every output has a mapping and throw an exception otherwise. </p>

</div>
</div>
<a id="a7dea1514ac756362ef9aa4545a7d13fa" name="a7dea1514ac756362ef9aa4545a7d13fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dea1514ac756362ef9aa4545a7d13fa">&#9670;&#160;</a></span>queryDerivationOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::queryDerivationOutputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the outputs of the derivation denoted by <code>path</code>. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1RemoteStore.html#af23df8a6632e37426cd96bc9e349099e">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a2d133a4cdaa811d75835a1cc61941d99" name="a2d133a4cdaa811d75835a1cc61941d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d133a4cdaa811d75835a1cc61941d99">&#9670;&#160;</a></span>queryMissing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::queryMissing </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structnix_1_1DerivedPath.html">DerivedPath</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>targets</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>willBuild</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>willSubstitute</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>unknown</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>downloadSize</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>narSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of paths that are to be built, return the set of derivations that will be built, and the set of output paths that will be substituted. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#a4a8970ce165796109b5f682eb68b0ca6">nix::RestrictedStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a08cbc94986ffedd0877944e6fb6a7a3a">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a2234cbe43e42284e2b51eb8761675bc9" name="a2234cbe43e42284e2b51eb8761675bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2234cbe43e42284e2b51eb8761675bc9">&#9670;&#160;</a></span>queryPartialDerivationOutputMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::map&lt; std::string, std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; &gt; nix::Store::queryPartialDerivationOutputMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnix_1_1Store.html">Store</a> *</td>          <td class="paramname"><span class="paramname"><em>evalStore</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the mapping outputName =&gt; outputPath for the given derivation. All outputs are mentioned so ones mising the mapping are mapped to <code>std::nullopt</code>. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#a12583925c2c4da9ae5acb08ab773885f">nix::RestrictedStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#ae805f529a32e9a01cf53dad0abe838b0">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a74ffbf449453a90e66b49775d4f64cde" name="a74ffbf449453a90e66b49775d4f64cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ffbf449453a90e66b49775d4f64cde">&#9670;&#160;</a></span>queryPathFromHashPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; nix::Store::queryPathFromHashPart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>hashPart</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the full store path given the hash part of a valid store path, or empty if the path doesn't exist. </p>

<p>Implemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a4ac31c342193be8eeed24a437b245090">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#af5d58b9abc48df0b7b04d74b8b303061">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a3f45d2c39bc558b4163f718dfb63dbd7">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a60524c9e4665f800a24bf213741207b2">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a0215164a363b955a7b3aced04f20324b">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#af542b3a5de1548e1f1e5568c22cd4485">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a23ba8ca476aa6273f160a39f3879d9c6" name="a23ba8ca476aa6273f160a39f3879d9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ba8ca476aa6273f160a39f3879d9c6">&#9670;&#160;</a></span>queryPathInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="classnix_1_1ref.html">ref</a>&lt; const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt; &gt; nix::Store::queryPathInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query information about a valid path. It is permitted to omit the name part of the store path. </p>

</div>
</div>
<a id="aa634a17855af0aad485087e32bc6adb4" name="aa634a17855af0aad485087e32bc6adb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa634a17855af0aad485087e32bc6adb4">&#9670;&#160;</a></span>queryPathInfoUncached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; std::shared_ptr&lt; const <a class="el" href="structnix_1_1ValidPathInfo.html">ValidPathInfo</a> &gt; &gt; &gt; nix::Store::queryPathInfoUncached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries the path info without caching. Note to implementors: should return <code>nullptr</code> when the path is not found. </p>

<p>Implemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#ab52591f56f59349c439c271edd7556d4">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#af178a94f8b9f87ee2251712edd495b06">nix::RestrictedStore</a>, <a class="el" href="structnix_1_1DummyStore.html#a1c60f95ce699c8d0e3502d58188ab554">nix::DummyStore</a>, <a class="el" href="structnix_1_1LegacySSHStore.html#a5709015760ae219f8eb2fd7407b98de8">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a0d9a35823db6f9e021a1cdd1f06af384">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#aaccec6d7c3a7091bf140bf4608c084ef">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a4cb914910edc81dfa19da71c3fdf9009" name="a4cb914910edc81dfa19da71c3fdf9009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb914910edc81dfa19da71c3fdf9009">&#9670;&#160;</a></span>queryRealisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::shared_ptr&lt; const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &gt; &gt; &gt; nix::Store::queryRealisation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnix_1_1DrvOutput.html">DrvOutput</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the information about a realisation. </p>

</div>
</div>
<a id="afedc853a718df8f6a3fbc91a686a7a52" name="afedc853a718df8f6a3fbc91a686a7a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedc853a718df8f6a3fbc91a686a7a52">&#9670;&#160;</a></span>queryReferrers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::queryReferrers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>referrers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries the set of incoming FS references for a store path. The result is not cleared. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1RestrictedStore.html#a163310efac856527c1b204f33d7b68dd">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a4e4edf810e65ddc5eb2d463b26c3da59">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a542505ec65a167c51db450f64eeaa1ff">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="ae59bbf6ee8b8d6dc4dd4dfe5f8afe454" name="ae59bbf6ee8b8d6dc4dd4dfe5f8afe454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59bbf6ee8b8d6dc4dd4dfe5f8afe454">&#9670;&#160;</a></span>queryStaticPartialDerivationOutputMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; std::map&lt; std::string, std::optional&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &gt; &gt; &gt; &gt; nix::Store::queryStaticPartialDerivationOutputMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <code>queryPartialDerivationOutputMap</code> but only considers statically known output paths (i.e. those that can be gotten from the derivation itself.</p>
<p>Just a helper function for implementing <code>queryPartialDerivationOutputMap</code>. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#aa781b7e83d3af25b03d137723a627411">nix::LocalStore</a>.</p>

</div>
</div>
<a id="a60d36d7aa385795d8e060c22073d929f" name="a60d36d7aa385795d8e060c22073d929f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d36d7aa385795d8e060c22073d929f">&#9670;&#160;</a></span>querySubstitutablePathInfos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::querySubstitutablePathInfos </td>
          <td>(</td>
          <td class="paramtype">const StorePathCAMap &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubstitutablePathInfos &amp;</td>          <td class="paramname"><span class="paramname"><em>infos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query substitute info (i.e. references, derivers and download sizes) of a map of paths to their optional ca values. The info of the first succeeding substituter for each path will be returned. If a path does not have substitute info, it's omitted from the resulting ‘infos’ map. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1RemoteStore.html#a4cc0ef02be49d1109b0f80ab2aef9a1d">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a14bc4ac5b3fc5287a901d7ad7b9e7c30" name="a14bc4ac5b3fc5287a901d7ad7b9e7c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bc4ac5b3fc5287a901d7ad7b9e7c30">&#9670;&#160;</a></span>querySubstitutablePaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::querySubstitutablePaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query which of the given paths have substitutes. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#a59d3a06dfed8b8674ccc222ebceac38f">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a9780981319c5fbc261276df5d4efc25c">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a020a11279779a0884547e42586a4f58b" name="a020a11279779a0884547e42586a4f58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020a11279779a0884547e42586a4f58b">&#9670;&#160;</a></span>queryValidDerivers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::queryValidDerivers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>all currently valid derivations that have <code>path</code> as an output.</dd></dl>
<p>(Note that the result of <code>queryDeriver()</code> is the derivation that was actually used to produce <code>path</code>, which may not exist anymore.) </p>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#a3388b686a0008017ad905882890731df">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#aee8765826269b05bab167f1893b992c1">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a800719163296e84486c5128bb1fe655d" name="a800719163296e84486c5128bb1fe655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800719163296e84486c5128bb1fe655d">&#9670;&#160;</a></span>queryValidPaths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; StorePathSet &gt; &gt; nix::Store::queryValidPaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubstituteFlag</td>          <td class="paramname"><span class="paramname"><em>maybeSubstitute</em><span class="paramdefsep"> = </span><span class="paramdefval">NoSubstitute</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query which of the given paths is valid. Optionally, try to substitute missing paths. </p>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a26bb02ff885e27d9c82187c1dd64cf22">nix::LegacySSHStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a47ff03a712774b0f17ab7fadc271baa5">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a7f75f8204d00a67fce81b729d201e779">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a309c37f4356be8e1f25ef6619bf2d964" name="a309c37f4356be8e1f25ef6619bf2d964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309c37f4356be8e1f25ef6619bf2d964">&#9670;&#160;</a></span>readDerivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt; nix::Store::readDerivation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drvPath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a derivation (which must already be valid). </p>

</div>
</div>
<a id="a61a12fdb30bfc05d0630889ce1a9ef26" name="a61a12fdb30bfc05d0630889ce1a9ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a12fdb30bfc05d0630889ce1a9ef26">&#9670;&#160;</a></span>readInvalidDerivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; <a class="el" href="structnix_1_1Derivation.html">Derivation</a> &gt; &gt; nix::Store::readInvalidDerivation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>drvPath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a derivation from a potentially invalid path. </p>

</div>
</div>
<a id="a6004e1965e5ab99e4af284c50cddd7d9" name="a6004e1965e5ab99e4af284c50cddd7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6004e1965e5ab99e4af284c50cddd7d9">&#9670;&#160;</a></span>registerDrvOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::registerDrvOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnix_1_1Realisation.html">Realisation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a mapping indicating that <code>deriver!outputName</code> maps to the output path <code>output</code>.</p>
<p>This is redundant for known-input-addressed and fixed-output derivations as this information is already present in the drv file, but necessary for floating-ca derivations and their dependencies as there's no way to retrieve this information otherwise. </p>

<p>Reimplemented in <a class="el" href="classnix_1_1BinaryCacheStore.html#a9a7480f7a0186d11fa77ab884b733156">nix::BinaryCacheStore</a>, <a class="el" href="structnix_1_1RestrictedStore.html#a577999e0934589d5859c1fbeb75b6bfb">nix::RestrictedStore</a>, <a class="el" href="classnix_1_1LocalStore.html#a8462a60718d4512f07ca64dad0abe2bd">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a94454ba1478aa2ff571bbab9582adccd">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="a5790dc114180dce23b412fdfd1f11231" name="a5790dc114180dce23b412fdfd1f11231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5790dc114180dce23b412fdfd1f11231">&#9670;&#160;</a></span>repairPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::repairPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnix_1_1StorePath.html">StorePath</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Repair the contents of the given path by redownloading it using a substituter (if available). </p>

<p>Reimplemented in <a class="el" href="structnix_1_1LegacySSHStore.html#a1e2db8b54e955dcd20f4f37e43143aa2">nix::LegacySSHStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a7cfda1f41d93cdf674beb61af5524759">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="aa195b57330d42b44b692b3900000ef79" name="aa195b57330d42b44b692b3900000ef79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa195b57330d42b44b692b3900000ef79">&#9670;&#160;</a></span>setOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::setOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronises the options of the client with those of the daemon (a no-op when there’s no daemon) </p>

<p>Reimplemented in <a class="el" href="classnix_1_1RemoteStore.html#a6669a93dfbcf1445c7a1e3e13f2036a0">nix::RemoteStore</a>.</p>

</div>
</div>
<a id="ac8542ed8b485ab578c7235bc93a4920d" name="ac8542ed8b485ab578c7235bc93a4920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8542ed8b485ab578c7235bc93a4920d">&#9670;&#160;</a></span>showPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string nix::Store::showPaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Display a set of paths in human-readable form (i.e., between quotes and separated by commas). </p>

</div>
</div>
<a id="aaf471f3994d70a3d176cdcef17d47cf7" name="aaf471f3994d70a3d176cdcef17d47cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf471f3994d70a3d176cdcef17d47cf7">&#9670;&#160;</a></span>substitutePaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; void &gt; &gt; nix::Store::substitutePaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If requested, substitute missing paths. This implements nix-copy-closure's &ndash;use-substitutes flag. </p>

</div>
</div>
<a id="a8aec8a2878825bfc4de7102fcff286f5" name="a8aec8a2878825bfc4de7102fcff286f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aec8a2878825bfc4de7102fcff286f5">&#9670;&#160;</a></span>topoSortPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Promise&lt; Result&lt; StorePaths &gt; &gt; nix::Store::topoSortPaths </td>
          <td>(</td>
          <td class="paramtype">const StorePathSet &amp;</td>          <td class="paramname"><span class="paramname"><em>paths</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort a set of paths topologically under the references relation. If p refers to q, then p precedes q in this list. </p>

</div>
</div>
<a id="af964f508806321bde6423c52a2634671" name="af964f508806321bde6423c52a2634671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af964f508806321bde6423c52a2634671">&#9670;&#160;</a></span>toStorePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classnix_1_1StorePath.html">StorePath</a>, <a class="el" href="types_8hh.html#a7844917eaf0a6a55da9c831973d234b2">Path</a> &gt; nix::Store::toStorePath </td>
          <td>(</td>
          <td class="paramtype">PathView</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a path like /nix/store/&lt;hash&gt;-&lt;name&gt;/&lt;bla&gt; into /nix/store/&lt;hash&gt;-&lt;name&gt; and /&lt;bla&gt;. </p>

</div>
</div>
<a id="ae88896cc85fd41e13c705ae7d430681a" name="ae88896cc85fd41e13c705ae7d430681a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88896cc85fd41e13c705ae7d430681a">&#9670;&#160;</a></span>unsupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nix::Store::unsupported </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for methods that are not unsupported: this is used for default definitions for virtual methods that are meant to be overriden.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo</a></b></dt><dd>Using this should be a last resort. It is better to make the method "virtual pure" and/or move it to a subclass. </dd></dl>

</div>
</div>
<a id="a2e8a5bda2e4455e95c241f850672b722" name="a2e8a5bda2e4455e95c241f850672b722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8a5bda2e4455e95c241f850672b722">&#9670;&#160;</a></span>verifyStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual kj::Promise&lt; Result&lt; bool &gt; &gt; nix::Store::verifyStore </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>checkContents</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RepairFlag</td>          <td class="paramname"><span class="paramname"><em>repair</em><span class="paramdefsep"> = </span><span class="paramdefval">NoRepair</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the integrity of the Nix store.</p>
<dl class="section return"><dt>Returns</dt><dd>true if errors remain. </dd></dl>

<p>Reimplemented in <a class="el" href="classnix_1_1LocalStore.html#abbbc24ac64ed5cf4f8ad3113aa9bf59f">nix::LocalStore</a>, and <a class="el" href="classnix_1_1RemoteStore.html#a8bbcf53f322748c62f26b06dbbf9c2e8">nix::RemoteStore</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lix/libstore/<a class="el" href="store-api_8hh_source.html">store-api.hh</a></li>
<li>lix/libstore/<b>export-import.cc</b></li>
<li>lix/libstore/<b>misc.cc</b></li>
<li>lix/libstore/<b>path.cc</b></li>
<li>lix/libstore/<b>store-api.cc</b></li>
<li>lix/libstore/build/<b>entry-points.cc</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>nix</b></li><li class="navelem"><a class="el" href="classnix_1_1Store.html">Store</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
